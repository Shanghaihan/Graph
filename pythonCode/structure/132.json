{"edges": [[0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [1, 2], [1, 0], [1, 3], [1, 4], [1, 5], [2, 1], [2, 0], [2, 3], [2, 4], [2, 5], [3, 1], [3, 2], [3, 0], [3, 4], [3, 5], [4, 1], [4, 2], [4, 0], [4, 3], [4, 5], [5, 1], [5, 2], [5, 0], [5, 3], [5, 4], [5, 6], [5, 7], [5, 8], [5, 9]], "features": {"0": "0", "1": "1", "2": "2", "3": "3", "4": "4", "5": "5", "6": "6", "7": "7", "8": "8", "9": "9"}, "count": 1, "cite": 1, "position": 3.0, "connect": 1.0, "totalConnect": 1.7894736842105263, "totalCount": 0.2, "totalCite": 3.0, "totalPosition": 5.5, "paper": [{"title": "Scalable Contour Tree Computation by Data Parallel Peak Pruning.", "author": ["Carr,Hamish", "Weber,GuntherH", "Sewell,Christopher", "Rubel,Oliver", "Fasel,Patricia", "Ahrens,James"], "soname": "IEEE transactions on visualization and computer graphics", "DOI": "10.1109/TVCG.2019.2948616", "keywords": "", "abstract": "As data sets grow to exascale, automated data analysis and visualisation are increasingly important, to intermediate human understanding and to reduce demands on disk storage via in situ analysis. Trends in architecture of high performance computing systems necessitate analysis algorithms to make effective use of combinations of massively multicore and distributed systems. One of the principal analytic tools is the contour tree, which analyses relationships between contours to identify features of more than local importance. Unfortunately, the predominant algorithms for computing the contour tree are explicitly serial, and founded on serial metaphors, which has limited the scalability of this form of analysis. While there is some work on distributed contour tree computation, and separately on hybrid GPU-CPU computation, there is no efficient algorithm with strong formal guarantees on performance allied with fast practical performance. We report the first shared SMP algorithm for fully parallel contour tree computation, with formal guarantees of O(lgnlgt) parallel steps and O(nlgn) work, and implementations with more than 30* parallel speed up on both CPU using TBB and GPU using Thrust and up 70* speed up compared to the serial sweep and merge algorithm.", "cite": 1, "year": "2019"}], "name": "Sewell,Christopher", "nodes": [{"id": "0"}, {"id": "1"}, {"id": "2"}, {"id": "3"}, {"id": "4"}, {"id": "5"}, {"id": "6"}, {"id": "7"}, {"id": "8"}, {"id": "9"}], "edgess": [{"source": "0", "target": "1"}, {"source": "0", "target": "2"}, {"source": "0", "target": "3"}, {"source": "0", "target": "4"}, {"source": "0", "target": "5"}, {"source": "1", "target": "2"}, {"source": "1", "target": "3"}, {"source": "1", "target": "4"}, {"source": "1", "target": "5"}, {"source": "2", "target": "3"}, {"source": "2", "target": "4"}, {"source": "2", "target": "5"}, {"source": "3", "target": "4"}, {"source": "3", "target": "5"}, {"source": "4", "target": "5"}, {"source": "5", "target": "6"}, {"source": "5", "target": "7"}, {"source": "5", "target": "8"}, {"source": "5", "target": "9"}], "year": 2019, "authorId": {"0": "Sewell,Christopher", "1": "Carr,Hamish", "2": "Weber,GuntherH", "3": "Rubel,Oliver", "4": "Fasel,Patricia", "5": "Ahrens,James", "6": "Orban,Daniel", "7": "Keefe,DanielF.", "8": "Biswas,Ayan", "9": "Rogers,David"}}